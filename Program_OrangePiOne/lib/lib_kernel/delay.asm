.section .text
.global delay

// 举个例子，如果CPU的频率是1MHz，也就是百万赫兹正好，就说明它一秒钟可以执行一百万次
// 一条指令就要执行一次

delay:
    // 纳秒值由r0传入，使用r1来实际计次
    // 循环体是两条语句，这两条语句都是单次执行，所以如果要正好计算一秒钟，那么r1应该设置为50万次（一百万除以2）

    // 这个CPU核心默认的的标称频率是1.2GHz（1200MHz），如果没有任何手动限制，应该都是这个频率
    // 那么一秒钟之内它应该能执行1200 * 1000 * 1000条语句
    // 1 ns = 10^(-9) s
    // 去掉九个0，1 ns之内能执行1.2条语句

    // r1的值是计次次数，要达到的结果是 r1 * 2 + （计算r1过程语句数量） + （最后一句bx） = r0 * 1.2
    // r1 = (r0 * 1.2 - （计算r1过程语句数量） - （最后一句bx） ) / 2

    // 这个实在是太难精确计算了，死马当活马医，只要数量级正确就行
    // 约等于1GHz，那么就是1 ns一条，直接把1.2的系数删掉了
    // 同时忽略掉计算过程语句数量和最后一句bx

    // 直接下面这样解决问题

    mov r1, r0          // 把r0的值赋予r1
    lsr r1, r1, #1      // 把r1的值右移一位，即除以2
delay_loop:
    sub r1, r1, #1      // 将r1减去1
    bne delay_loop      // 如果计算结果为0，cpsr的运算结果为0标志位会更新，所以可以直接判断，如果不为0就跳回去
return_caller:
    bx  lr              // 执行完毕返回调用者
