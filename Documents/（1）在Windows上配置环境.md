# （一）在Windows上配置环境

## 1. 下载安装工具

[Bochs官网](https://bochs.sourceforge.io/)

[NASM官网](https://www.nasm.us/)

[dd for Windows](http://www.chrysocome.net/dd)

三个工具下载我就不多说了。安装的话只有Bochs需要具体的安装过程，NASM和dd都是只需要解压就可以使用的，三个工具最好解压到全英文路径。

三个工具的目录都要添加到环境变量，以后用起来比较方便。

![](.\pic\1.png)

![](.\pic\2.png)



## 2. Bochs虚拟机配置和启动

用bximage创建一个硬盘镜像，过程如下：

```bash
C:\Users\huang\Desktop\Repository\HOS\VM>bximage
========================================================================
                                bximage
  Disk Image Creation / Conversion / Resize and Commit Tool for Bochs
         $Id: bximage.cc 13481 2018-03-30 21:04:04Z vruppert $
========================================================================

1. Create new floppy or hard disk image
2. Convert hard disk image to other format (mode)
3. Resize hard disk image
4. Commit 'undoable' redolog to base image
5. Disk image info

0. Quit

Please choose one [0] 1

Create image

Do you want to create a floppy disk image or a hard disk image?
Please type hd or fd. [hd] hd

What kind of image should I create?
Please type flat, sparse, growing, vpc or vmware4. [flat] flat

Choose the size of hard disk sectors.
Please type 512, 1024 or 4096. [512] 512

Enter the hard disk size in megabytes, between 10 and 8257535
[10] 64

What should be the name of the image?
[c.img] HOS.img

Creating hard disk image 'HOS.raw' with CHS=130/16/63 (sector size = 512)

The following line should appear in your bochsrc:
  ata0-master: type=disk, path="HOS.raw", mode=flat
(The line is stored in your windows clipboard, use CTRL-V to paste)

```

用 .raw 这个后缀是因为我之前用VirtualBox发现这个后缀是 VirtualBox 提供的二进制硬盘模拟文件，也可以直接在 VirtualBox 上作为硬盘加载，反正Bochs虚拟机对于 bximage 生成出来的什么格式后缀都能用，我就设置成.raw了。

然后配置Bochs的启动配置 Configuration.bxrc

```ini
# configuration file generated by Bochs
plugin_ctrl: unmapped=true, biosdev=true, speaker=true, extfpuirq=true, parallel=true, serial=true, gameport=true
# 插件控制：启用未映射、BIOS设备、扬声器、外部FPU中断请求、并行端口、串行端口和游戏端口

config_interface: win32config
# 配置接口：Windows 32位配置界面

display_library: win32
# 显示库：使用Windows显示库

memory: host=32, guest=32
# 内存：主机和客户机均分配32MB内存

romimage: file="C:/bochs/Bochs-2.6.11/BIOS-bochs-latest", address=0x00000000, options=none
# ROM映像：BIOS映像文件路径，加载地址为0x00000000，无选项

vgaromimage: file="C:/bochs/Bochs-2.6.11/VGABIOS-lgpl-latest"
# VGA ROM映像：VGA BIOS映像文件路径

boot: disk
# 启动顺序：从磁盘启动

floppy_bootsig_check: disabled=0
# 软盘引导签名检查：未禁用

# no floppya
# 无软盘A

# no floppyb
# 无软盘B

ata0: enabled=true, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
# ATA控制器0：启用，IO地址1=0x1f0，IO地址2=0x3f0，中断请求14

ata0-master: type=disk, path="C:/Users/huang/Desktop/Repository/HOS/VM/HOS.raw", mode=flat, cylinders=130, heads=16, spt=63, sect_size=512, model="Generic 1234", biosdetect=auto, translation=auto
# ATA控制器0主设备：类型为磁盘，路径为HOS.raw，扁平模式，130个柱面，16个磁头，每柱面63个扇区，扇区大小512字节，型号为"Generic 1234"，BIOS检测为自动，转换方式为自动

ata0-slave: type=none
# ATA控制器0从设备：无设备

ata1: enabled=false
# ATA控制器1：禁用

ata2: enabled=false
# ATA控制器2：禁用

ata3: enabled=false
# ATA控制器3：禁用

optromimage1: file=none
optromimage2: file=none
optromimage3: file=none
optromimage4: file=none
# 可选ROM映像1至4：无文件

optramimage1: file=none
optramimage2: file=none
optramimage3: file=none
optramimage4: file=none
# 可选RAM映像1至4：无文件

pci: enabled=1, chipset=i440fx
# PCI：启用，芯片组为i440fx

vga: extension=vbe, update_freq=5, realtime=1
# VGA：扩展为VBE，更新频率为5，实时为1

cpu: count=1, ips=4000000, model=bx_generic, reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0
# CPU：数量为1，指令每秒4000000，型号为bx_generic，三重故障时重置，CPUID限制为WinNT，忽略错误的MSR，MWAIT为NOP

cpuid: level=6, stepping=3, model=3, family=6, vendor_string="GenuineIntel", brand_string="              Intel(R) Pentium(R) 4 CPU        "
# CPUID：级别为6，步进为3，型号为3，家族为6，厂商字符串为"GenuineIntel"，品牌字符串为"Intel(R) Pentium(R) 4 CPU"

cpuid: mmx=true, apic=xapic, simd=sse2, sse4a=false, misaligned_sse=false, sep=true
# CPUID：MMX支持，APIC为xAPIC，SIMD支持SSE2，不支持SSE4a，不支持未对齐的SSE，支持SEP

cpuid: movbe=false, adx=false, aes=false, sha=false, xsave=false, xsaveopt=false, x86_64=true
# CPUID：不支持MOVBE，不支持ADX，不支持AES，不支持SHA，不支持XSAVE，不支持XSAVEOPT，支持x86_64

cpuid: 1g_pages=false, pcid=false, fsgsbase=false, smep=false, smap=false, mwait=true
# CPUID：不支持1GB页，不支持PCID，不支持FSGSBASE，不支持SMEP，不支持SMAP，支持MWAIT

cpuid: vmx=1
# CPUID：支持VMX

print_timestamps: enabled=0
# 打印时间戳：禁用

port_e9_hack: enabled=0
# E9端口黑客：禁用

private_colormap: enabled=0
# 私有颜色映射：禁用

clock: sync=none, time0=local, rtc_sync=0
# 时钟：不同步，初始时间为本地时间，不同步RTC

# no cmosimage
# 无CMOS映像

log: C:/Users/huang/Desktop/Repository/HOS/VM/bochsout.txt
# 日志文件路径：C:\Users\huang\Desktop\Repository\HOS\VM\bochsout.txt

logprefix: %t%e%d
# 日志前缀：时间、事件、日期

debug: action=ignore
# 调试：忽略动作

info: action=report
# 信息：报告动作

error: action=report
# 错误：报告动作

panic: action=ask
# 恐慌：询问动作

keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none
# 键盘：类型为mf，串行延迟250，粘贴延迟100000，无用户快捷键

mouse: type=ps2, enabled=false, toggle=ctrl+mbutton
# 鼠标：类型为ps2，禁用，切换键为ctrl+中键

sound: waveoutdrv=win, waveout=none, waveindrv=win, wavein=none, midioutdrv=win, midiout=none
# 声音：wave输出驱动为win，无wave输出，wave输入驱动为win，无wave输入，MIDI输出驱动为win，无MIDI输出

speaker: enabled=true, mode=sound
# 扬声器：启用，模式为声音

parport1: enabled=true, file=none
# 并行端口1：启用，无文件

parport2: enabled=false
# 并行端口2：禁用

com1: enabled=true, mode=null
# 串行端口1：启用，模式为null

com2: enabled=false
# 串行端口2：禁用

com3: enabled=false
# 串行端口3：禁用

com4: enabled=false
# 串行端口4：禁用

```

看着多，其实要改的不多，就这几项

```ini
romimage: file="C:/bochs/Bochs-2.6.11/BIOS-bochs-latest", address=0x00000000, options=none
# ROM映像：BIOS映像文件路径，加载地址为0x00000000，无选项

vgaromimage: file="C:/bochs/Bochs-2.6.11/VGABIOS-lgpl-latest"
# VGA ROM映像：VGA BIOS映像文件路径

log: C:/Users/huang/Desktop/Repository/HOS/VM/bochsout.txt
# 日志文件路径：C:\Users\huang\Desktop\Repository\HOS\VM\bochsout.txt
```

改为自己的bochs安装目录，指定日志输出位置

```ini
ata0-master: type=disk, path="C:/Users/huang/Desktop/Repository/HOS/VM/HOS.raw", mode=flat, cylinders=130, heads=16, spt=63, sect_size=512, model="Generic 1234", biosdetect=auto, translation=auto
# ATA控制器0主设备：类型为磁盘，路径为HOS.raw，扁平模式，130个柱面，16个磁头，每柱面63个扇区，扇区大小512字节，型号为"Generic 1234"，BIOS检测为自动，转换方式为自动

```

首先改自己的镜像路径。

之前用bximage生成镜像的时候，最后的输出如下

```bash
Creating hard disk image 'HOS.raw' with CHS=130/16/63 (sector size = 512)
```

CHS，三个字母分别是cylinders，heads，spt三个单词的首字母，sector size缩写也就是sect_size。

修改这些东西，配置文件就做好了。

然后启动Bochs，Windows下的Bochs交互界面做得非常差，而且没有中文，不过还好我们不关心这个，能用就行。

![](.\pic\3.png)

点击Load，载入配置，点击start就行了。

其实也可以不用配置，直接在这个界面现场配置，但是太多，配置起来太痛苦了，还是算了。

也可以直接用命令行直接加载配置启动。

```bash
bochs -f 你的Configuration.bxrc所在的文件夹/Configuration.bxrc
```

我做了个简单的start_bochs.bat脚本，放在 Configuration.bxrc 所在的目录下了，直接用这个一键加载配置启动。

```bash
@echo off
REM 检查当前目录下是否存在Configuration.bxrc文件
if exist Configuration.bxrc (
    
    REM 使用绝对路径启动Bochs
    bochs -f %~dp0Configuration.bxrc
    
) else (
    REM 如果不存在Configuration.bxrc文件，输出提示信息并退出
    echo Configuration.bxrc文件不存在，程序将退出。
    exit /b
)

```



## 3. 烧写MBR

就用书里给的那个初始的MBR（就是那个只在屏幕上打印一行“1 MBR”的），尝试烧写到HOS.raw文件中，然后再启动虚拟机，看看效果。

MBR代码如下：

```assembly
;主引导程序
;------------------------------------------------------------
SECTION MBR vstart=0x7c00
   mov ax,cs
   mov ds,ax
   mov es,ax
   mov ss,ax
   mov fs,ax
   mov sp,0x7c00

; 清屏 利用0x06号功能，上卷全部行，则可清屏。
; -----------------------------------------------------------
;INT 0x10   功能号:0x06	   功能描述:上卷窗口
;------------------------------------------------------
;输入：
;AH 功能号= 0x06
;AL = 上卷的行数(如果为0,表示全部)
;BH = 上卷行属性
;(CL,CH) = 窗口左上角的(X,Y)位置
;(DL,DH) = 窗口右下角的(X,Y)位置
;无返回值：
   mov     ax, 0x600
   mov     bx, 0x700
   mov     cx, 0           ; 左上角: (0, 0)
   mov     dx, 0x184f	   ; 右下角: (80,25),
			   ; VGA文本模式中,一行只能容纳80个字符,共25行。
			   ; 下标从0开始,所以0x18=24,0x4f=79
   int     0x10            ; int 0x10

;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
;.get_cursor获取当前光标位置,在光标位置处打印字符.
   mov ah, 3		; 输入: 3号子功能是获取光标位置,需要存入ah寄存器
   mov bh, 0		; bh寄存器存储的是待获取光标的页号

   int 0x10		; 输出: ch=光标开始行,cl=光标结束行
			; dh=光标所在行号,dl=光标所在列号

;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

;;;;;;;;;     打印字符串    ;;;;;;;;;;;
   ;还是用10h中断,不过这次是调用13号子功能打印字符串
   mov ax, message
   mov bp, ax		; es:bp 为串首地址, es此时同cs一致，
			; 开头时已经为sreg初始化

   ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
   mov cx, 5		; cx 为串长度,不包括结束符0的字符个数
   mov ax, 0x1301	; 子功能号13是显示字符及属性,要存入ah寄存器,
			; al设置写字符方式 ah=01: 显示字符串,光标跟随移动
   mov bx, 0x2		; bh存储要显示的页号,此处是第0页,
			; bl中是字符属性, 属性黑底绿字(bl = 02h)
   int 0x10		; 执行BIOS 0x10 号中断
;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

   jmp $		; 使程序悬停在此

   message db "1 MBR"
   times 510-($-$$) db 0
   db 0x55,0xaa

```



我们的项目结构

```
HOS
└──── Program
      └──── boot
            └── mbr.asm
      └──── (未来会有更多部分的代码)
      └──── Makefile
      └──── w.bat
└──── VM
      └──── Configuration.bxrc
      └──── HOS.raw
```

解释一下，Program存放的是真正的项目代码和编译文件，VM存放的是虚拟机相关的文件。

我个人习惯用asm后缀，实际上对NASM而言没区别。

项目使用Makefile，一开始就用。

w.bat 是我做的一键编译并烧写脚本，用这个可以一次性执行make和多次dd操作，最后还能直接clean，起这个名字是write的首字母，主要是懒。

目前第一个版本的Makefile如下：

```makefile
# Makefile 用于编译项目

# 汇编器和编译器
NASM = nasm

# 路径
BOOT_DIR = boot

# 文件
MBR_SRC = $(BOOT_DIR)/mbr.asm

# 输出文件
MBR_BIN = $(BOOT_DIR)/mbr.bin

# 汇编标志
ASM_FLAGS = -f bin

.PHONY: all

all: $(MBR_BIN)

# 编译 mbr.bin
$(MBR_BIN): $(MBR_SRC)
	$(NASM) $(ASM_FLAGS) -o $@ $<

# 清理规则
clean:
	@if exist $(BOOT_DIR)\\*.bin del $(BOOT_DIR)\\*.bin

```

一键编译烧写脚本w.bat如下：

```bash
@echo off

rem 先执行make操作
make all

setlocal

rem 确定mbr.bin文件的路径
set MBR_BIN=%~dp0boot\mbr.bin

rem 确定目标硬盘映像文件的相对路径
set HD_IMG_REL=..\VM\HOS.raw

rem 计算目标硬盘映像文件的绝对路径
for %%I in (%HD_IMG_REL%) do set HD_IMG=%%~fI

rem 输出涉及各文件的路径信息
echo MBR_BIN=%MBR_BIN%
echo HD_IMG=%HD_IMG%

rem 切换到脚本所在的目录
cd /d %~dp0

rem 首先清空硬盘
dd if=/dev/zero of=%HD_IMG% bs=1M count=64 conv=notrunc
rem 使用dd将mbr.bin写入硬盘映像文件
dd if=%MBR_BIN% of=%HD_IMG% bs=512 count=1 conv=notrunc

rem 执行clean操作
make clean

endlocal
pause

```

一键编译烧写，启动虚拟机，点击start开始模拟。

可以看到和书中一模一样的效果。

![](.\pic\4.png)

![](.\pic\5.png)

